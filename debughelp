// ============================================================================
// TROUBLESHOOTING gRPC CHANNEL CREATION ISSUES
// ============================================================================

// STEP 1: Fix Configuration Issues
// ============================================================================

// Option A: Simplified GrpcClientConfig.java (Remove custom ChannelBuilder)
@Configuration
public class GrpcClientConfig {
    
    // Remove custom @Bean definitions - let Spring Boot auto-configure
    // The @GrpcClient annotation will handle channel creation automatically
    
    // Optional: Only add custom configuration if you need specific settings
    @Bean
    @ConditionalOnProperty(name = "grpc.client.custom-config.enabled", havingValue = "true")
    public NettyChannelBuilder customChannelBuilder() {
        return NettyChannelBuilder.forAddress("localhost", 9090)
                .keepAliveTime(30, TimeUnit.SECONDS)
                .keepAliveTimeout(5, TimeUnit.SECONDS)
                .keepAliveWithoutCalls(true)
                .usePlaintext();
    }
}

// ============================================================================
// STEP 2: Fix Application Properties
// ============================================================================

/*
# application.yml - Correct Configuration
grpc:
  client:
    quarkus-user-service:
      address: 'static://localhost:9090'
      negotiationType: plaintext
      keepAliveTime: 30s
      keepAliveTimeout: 5s
      keepAliveWithoutCalls: true
      maxInboundMessageSize: 4194304
      # Add these if you're having connection issues
      enableRetry: true
      maxRetryAttempts: 3
      
# Alternative configuration if using discovery
    quarkus-user-service-discovery:
      address: 'discovery:///user-service'  # If using service discovery
      negotiationType: plaintext

# Enable debug logging
logging:
  level:
    io.grpc: DEBUG
    net.devh.boot.grpc.client: DEBUG
    com.yourcompany.apibridge: DEBUG
*/

// ============================================================================
// STEP 3: Improved gRPC Client Implementation
// ============================================================================

@Service
@Slf4j
public class QuarkusUserClient {

    @GrpcClient("quarkus-user-service")
    private UserServiceGrpc.UserServiceBlockingStub userServiceStub;

    @GrpcClient("quarkus-user-service")
    private UserServiceGrpc.UserServiceStub userServiceAsyncStub;
    
    // Add channel for connection monitoring
    @GrpcClient("quarkus-user-service")
    private Channel channel;
    
    @PostConstruct
    public void init() {
        log.info("QuarkusUserClient initialized");
        // Test connection on startup (optional)
        testConnection();
    }
    
    private void testConnection() {
        try {
            // Simple connectivity test
            ConnectivityState state = ((ManagedChannel) channel).getState(true);
            log.info("gRPC Channel initial state: {}", state);
        } catch (Exception e) {
            log.warn("Could not test gRPC connection on startup: {}", e.getMessage());
        }
    }

    public UserProto.User createUser(UserProto.CreateUserRequest request) {
        try {
            // Check connection state before making call
            ConnectivityState state = ((ManagedChannel) channel).getState(false);
            log.debug("Channel state before call: {}", state);
            
            return userServiceStub.createUser(request);
        } catch (StatusRuntimeException e) {
            log.error("gRPC call failed with status: {} - {}", e.getStatus().getCode(), e.getStatus().getDescription());
            throw new GrpcServiceException("User creation failed", "user-service", e);
        } catch (Exception e) {
            log.error("Unexpected error calling user service", e);
            throw new QuarkusServiceUnavailableException("user-service", e);
        }
    }
    
    // Add health check method
    public boolean isServiceAvailable() {
        try {
            ConnectivityState state = ((ManagedChannel) channel).getState(false);
            return state == ConnectivityState.READY || state == ConnectivityState.IDLE;
        } catch (Exception e) {
            log.warn("Error checking service availability: {}", e.getMessage());
            return false;
        }
    }
}

// ============================================================================
// STEP 4: Add Connection Health Check
// ============================================================================

@Component
@Slf4j
public class GrpcConnectionHealthCheck {

    @Autowired
    private QuarkusUserClient userClient;
    
    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationReady() {
        // Check connections after application starts
        checkConnections();
    }
    
    @Scheduled(fixedRate = 30000) // Check every 30 seconds
    public void checkConnections() {
        boolean isAvailable = userClient.isServiceAvailable();
        log.info("Quarkus User Service availability: {}", isAvailable);
        
        if (!isAvailable) {
            log.warn("Quarkus User Service is not available");
            // Could implement alerting here
        }
    }
}

// ============================================================================
// STEP 5: Conditional Bean Creation (Fallback Strategy)
// ============================================================================

@Configuration
public class GrpcClientConditionalConfig {

    @Bean
    @ConditionalOnProperty(name = "grpc.client.fallback.enabled", havingValue = "true")
    public QuarkusUserClient fallbackUserClient() {
        return new QuarkusUserClientFallback();
    }
    
    // Fallback implementation when gRPC is not available
    @Component
    @ConditionalOnProperty(name = "grpc.client.fallback.enabled", havingValue = "true")
    public static class QuarkusUserClientFallback extends QuarkusUserClient {
        
        @Override
        public UserProto.User createUser(UserProto.CreateUserRequest request) {
            log.warn("Using fallback - gRPC service not available");
            throw new QuarkusServiceUnavailableException("user-service");
        }
        
        @Override
        public boolean isServiceAvailable() {
            return false;
        }
    }
}

// ============================================================================
// STEP 6: Startup Connection Test
// ============================================================================

@Component
@Slf4j
public class GrpcStartupValidator implements ApplicationRunner {

    @Autowired(required = false)
    private QuarkusUserClient userClient;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        if (userClient != null) {
            log.info("Testing gRPC connections on startup...");
            
            try {
                boolean available = userClient.isServiceAvailable();
                
                if (available) {
                    log.info("✅ gRPC connection to Quarkus User Service: SUCCESS");
                } else {
                    log.warn("⚠️ gRPC connection to Quarkus User Service: NOT READY");
                }
                
            } catch (Exception e) {
                log.error("❌ gRPC connection test failed: {}", e.getMessage());
                // Don't fail startup, just log the issue
            }
        }
    }
}

// ============================================================================
// STEP 7: Debug Configuration
// ============================================================================

@Configuration
@Profile("debug")
public class GrpcDebugConfig {

    @Bean
    public ClientInterceptor grpcDebugInterceptor() {
        return new ClientInterceptor() {
            @Override
            public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
                    MethodDescriptor<ReqT, RespT> method, 
                    CallOptions callOptions, 
                    Channel next) {
                
                log.debug("gRPC Call: {}", method.getFullMethodName());
                
                return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(
                        next.newCall(method, callOptions)) {
                    
                    @Override
                    public void start(Listener<RespT> responseListener, Metadata headers) {
                        log.debug("Starting call to: {}", method.getFullMethodName());
                        super.start(new ForwardingClientCallListener.SimpleForwardingClientCallListener<RespT>(responseListener) {
                            @Override
                            public void onClose(Status status, Metadata trailers) {
                                log.debug("Call completed with status: {}", status);
                                super.onClose(status, trailers);
                            }
                        }, headers);
                    }
                };
            }
        };
    }
}

// ============================================================================
// COMMON SOLUTIONS CHECKLIST
// ============================================================================

/*
TROUBLESHOOTING CHECKLIST:

1. ✅ QUARKUS SERVICE RUNNING?
   - Check if your Quarkus application is running on the expected port
   - Test: telnet localhost 9090

2. ✅ CORRECT PORT CONFIGURATION?
   - Verify port in application.yml matches Quarkus gRPC port
   - Check: netstat -an | grep 9090

3. ✅ FIREWALL/NETWORK ISSUES?
   - Ensure no firewall blocking the connection
   - Try connecting from same machine first

4. ✅ PROTO COMPATIBILITY?
   - Ensure proto files are identical between Spring Boot and Quarkus
   - Check generated classes are up to date

5. ✅ DEPENDENCIES CORRECT?
   - Check Spring Boot gRPC starter version compatibility
   - Verify all required dependencies are present

6. ✅ PLAINTEXT VS TLS?
   - Ensure both client and server use same security configuration
   - Use 'negotiationType: plaintext' for local development

7. ✅ SERVICE NAME MATCHING?
   - @GrpcClient("service-name") must match configuration key
   - Case sensitive!

8. ✅ SPRING BOOT VERSION COMPATIBILITY?
   - Check compatibility matrix for grpc-spring-boot-starter

QUICK FIXES:

1. Simplify configuration - remove custom beans
2. Add 'negotiationType: plaintext' 
3. Check service is actually running
4. Enable debug logging
5. Add connection health checks
6. Use fallback strategies for development

DEVELOPMENT TIPS:

1. Start Quarkus service first
2. Enable debug logging during development
3. Use health checks to monitor connections
4. Implement graceful degradation
5. Add retry mechanisms for production
*/